// Fill out your copyright notice in the Description page of Project Settings.

#include "UnrealMosquittoRouter.h"
#include "UEmqtt.h"
#include "UnrealMosquittoRoutingLibrary.h"

#include "Kismet/KismetStringLibrary.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "UnrealEd.h"
#include "EditorCategoryUtils.h"
#include "SlateBasics.h"
#include "EdGraph/EdGraphPin.h"
#include "EdGraph/EdGraphSchema.h"
#include "EdGraphSchema_K2.h"
#include "EdGraphUtilities.h"

/*UUnrealMosquittoRouter::UUnrealMosquittoRouter(const FObjectInitializer& ObjectInitializer)
: Super(ObjectInitializer)
{
/*FunctionClass = UUnrealMosquittoRoutingLibrary::StaticClass();
FunctionName = TEXT("RoutingNotMatched");
}*/

/*void UUnrealMosquittoRouter::GetContextMenuActions(const FGraphNodeContextMenuBuilder & Context) const
{
Super::GetContextMenuAction(Context);
}*/
/**/
FString UUnrealMosquittoRouter::GetPinNameGivenIndex(int32 Index)
{
	return Routes[Index];
}

void UUnrealMosquittoRouter::CreateFunctionPin()
{
	FunctionName = TEXT("RoutingNotMatched");
	FunctionClass = UUnrealMosquittoRoutingLibrary::StaticClass();
	// Set properties on the function pin
	const UEdGraphSchema_K2 *K2Schema = GetDefault<UEdGraphSchema_K2>();
	UEdGraphPin *FunctionPin = CreatePin(EGPD_Input, K2Schema->PC_Object, TEXT(""),
										 FunctionClass, false, false, FunctionName.ToString());
	FunctionPin->bDefaultValueIsReadOnly = true;
	FunctionPin->bNotConnectable = true;
	FunctionPin->bHidden = true;

	UFunction *Function = FindField<UFunction>(FunctionClass, FunctionName);
	const bool bIsStaticFunc = Function->HasAllFunctionFlags(FUNC_Static);
	if (bIsStaticFunc)
	{
		// Wire up the self to the CDO of the class if it's not us
		if (UBlueprint *BP = GetBlueprint())
		{
			UClass *FunctionOwnerClass = Function->GetOuterUClass();
			if (!BP->SkeletonGeneratedClass->IsChildOf(FunctionOwnerClass))
			{
				FunctionPin->DefaultObject = FunctionOwnerClass->GetDefaultObject();
			}
		}
	}
}

void UUnrealMosquittoRouter::PostEditChangeProperty(FPropertyChangedEvent &PropertyChangedEvent)
{
	bool bIsDirty = false;
	FName PropertyName = (PropertyChangedEvent.Property != NULL) ? PropertyChangedEvent.Property->GetFName() : NAME_None;
	if (PropertyName == TEXT("Routes"))
	{
		bIsDirty = true;
		/*FunctionClass = UUnrealMosquittoRoutingLibrary::StaticClass();
		FunctionName = TEXT("RoutingNotMatched");*/
	}

	if (bIsDirty)
	{
		ReconstructNode();
		GetGraph()->NotifyGraphChanged();
	}
	Super::PostEditChangeProperty(PropertyChangedEvent);
}

void UUnrealMosquittoRouter::GetMenuActions(FBlueprintActionDatabaseRegistrar &ActionRegistrar) const
{
	// actions get registered under specific object-keys; the idea is that
	// actions might have to be updated (or deleted) if their object-key is
	// mutated (or removed)... here we use the node's class (so if the node
	// type disappears, then the action should go with it)
	UClass *ActionKey = GetClass();
	// to keep from needlessly instantiating a UBlueprintNodeSpawner, first
	// check to make sure that the registrar is looking for actions of this type
	// (could be regenerating actions for a specific asset, and therefore the
	// registrar would only accept actions corresponding to that asset)
	if (ActionRegistrar.IsOpenForRegistration(ActionKey))
	{
		UBlueprintNodeSpawner *NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
		check(NodeSpawner != nullptr);

		ActionRegistrar.AddBlueprintAction(ActionKey, NodeSpawner);
	}
}

FText UUnrealMosquittoRouter::GetTooltipText() const
{
	return NSLOCTEXT("K2Node", "UnrealMosquittoRouterTooltip", "Route based on the input string");
}

FText UUnrealMosquittoRouter::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	return NSLOCTEXT("K2Node", "UnrealMosquittoRouter", "Route on String");
}

FLinearColor UUnrealMosquittoRouter::GetNodeTitleColor() const
{
	// Better yellow
	//return FLinearColor(255.0f, 0.0f, 0.0f);
	return FLinearColor(128.0f, 128.0f, 0.0f);
}

void UUnrealMosquittoRouter::AddPinToSwitchNode()
{
	FString PinName = FString("/richard");
	Routes.Add(PinName);

	const UEdGraphSchema_K2 *K2Schema = GetDefault<UEdGraphSchema_K2>();
	CreatePin(EGPD_Output, K2Schema->PC_Exec, TEXT(""), NULL, false, false, PinName);
	/*FunctionClass = UUnrealMosquittoRoutingLibrary::StaticClass();
	FunctionName = TEXT("RoutingNotMatched");*/
}

FEdGraphPinType UUnrealMosquittoRouter::GetPinType() const
{
	FEdGraphPinType PinType;
	PinType.PinCategory = UEdGraphSchema_K2::PC_String;
	return PinType;
}

void UUnrealMosquittoRouter::CreateSelectionPin()
{
	// If we inherits from UK2Node_Switch, it must be called Selection
	const UEdGraphSchema_K2 *K2Schema = GetDefault<UEdGraphSchema_K2>();
	UEdGraphPin *Pin = CreatePin(EGPD_Input, K2Schema->PC_String, TEXT(""), NULL, false, false, TEXT("Selection"));
	//K2Schema->SetPinDefaultValueBasedOnType(Pin);
	K2Schema->SetPinAutogeneratedDefaultValue(Pin, FString());
}

void UUnrealMosquittoRouter::CreateCasePins()
{
	const UEdGraphSchema_K2 *K2Schema = GetDefault<UEdGraphSchema_K2>();
	for (TArray<FString>::TIterator it(Routes); it; ++it)
	{
		CreatePin(EGPD_Output, K2Schema->PC_Exec, TEXT(""), NULL, false, false, *it);
	}
	/*FunctionClass = UUnrealMosquittoRoutingLibrary::StaticClass();
	FunctionName = TEXT("RoutingNotMatched");*/
}

void UUnrealMosquittoRouter::RemovePin(UEdGraphPin *TargetPin)
{
	checkSlow(TargetPin);

	// Clean-up pin name array
	Routes.Remove(TargetPin->PinName);
}